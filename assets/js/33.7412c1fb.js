(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{356:function(v,_,e){"use strict";e.r(_);var t=e(34),a=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[v._v("#")]),v._v(" 缓存")]),v._v(" "),e("p",[v._v("浏览器请求网站资源后留下的资源副本")]),v._v(" "),e("h2",{attrs:{id:"缓存的作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存的作用"}},[v._v("#")]),v._v(" 缓存的作用")]),v._v(" "),e("ul",[e("li",[v._v("缓解服务器压力")]),v._v(" "),e("li",[v._v("提升性能（重复资源不用再请求，加快访问速度）")]),v._v(" "),e("li",[v._v("减少带宽消耗")])]),v._v(" "),e("h2",{attrs:{id:"缓存分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存分类"}},[v._v("#")]),v._v(" 缓存分类")]),v._v(" "),e("ul",[e("li",[v._v("私有缓存")]),v._v(" "),e("li",[v._v("共享缓存")])]),v._v(" "),e("h2",{attrs:{id:"浏览器缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存"}},[v._v("#")]),v._v(" 浏览器缓存")]),v._v(" "),e("ul",[e("li",[e("strong",[v._v("Cache-Control(HTTP 1.1)")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("private")]),v._v(" 该资源只能被浏览器缓存")]),v._v(" "),e("li",[e("code",[v._v("public")]),v._v(" 该资源既能被浏览器缓存，也能被中间人（如代理服务器、CDN缓存）")]),v._v(" "),e("li",[e("code",[v._v("max-age")]),v._v(" 该资源能被缓存的最大时间")]),v._v(" "),e("li",[e("code",[v._v("no-cache")]),v._v(" 不缓存过期资源，相当于"),e("code",[v._v("max-age=0")]),v._v("，缓存立刻过期。需要与服务器确认资源是否更新")]),v._v(" "),e("li",[e("code",[v._v("no-store")]),v._v(" 不准缓存")])])]),v._v(" "),e("li",[e("strong",[v._v("Expires(HTTP 1.0)")]),v._v(" "),e("ul",[e("li",[v._v("标识了缓存的具体过期时间，来控制资源何时过期。通过设置 "),e("code",[v._v("Expires")]),v._v(" 可以启用缓存。不过需要注意 "),e("code",[v._v("Expires")]),v._v(" 的值是格林威治时间（Greenwich Mean Time, GMT），不是本地时间")]),v._v(" "),e("li",[e("code",[v._v("Expires=0")]),v._v("时，仍然会启用缓存，只是过期时间为0，即马上就会过期")])])])]),v._v(" "),e("blockquote",[e("p",[e("strong",[v._v("Cache-Control")]),v._v(" 优先级高于 "),e("strong",[v._v("Expires")])])]),v._v(" "),e("h2",{attrs:{id:"缓存位置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存位置"}},[v._v("#")]),v._v(" 缓存位置")]),v._v(" "),e("p",[e("img",{attrs:{src:"/img/cache.png",alt:"浏览器缓存"}}),v._v("\n浏览器缓存优先级："),e("code",[v._v("Service Worker")]),v._v(" -> "),e("code",[v._v("Memory Cache")]),v._v(" -> "),e("code",[v._v("Disk Cache")]),v._v(" -> "),e("code",[v._v("Push Cache")])]),v._v(" "),e("h2",{attrs:{id:"缓存方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存方式"}},[v._v("#")]),v._v(" 缓存方式")]),v._v(" "),e("ul",[e("li",[v._v("强制缓存\n"),e("ul",[e("li",[e("code",[v._v("Cache-Control")])]),v._v(" "),e("li",[e("code",[v._v("Expires")])])])]),v._v(" "),e("li",[v._v("协商缓存\n"),e("ul",[e("li",[e("code",[v._v("Last-Modified，If-Modified-Since")])]),v._v(" "),e("li",[e("code",[v._v("ETag、If-None-Match")])])])])]),v._v(" "),e("h3",{attrs:{id:"为何使用etag"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为何使用etag"}},[v._v("#")]),v._v(" 为何使用ETag")]),v._v(" "),e("ul",[e("li",[v._v("一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET")]),v._v(" "),e("li",[v._v("某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)")]),v._v(" "),e("li",[v._v("某些服务器不能精确的得到文件的最后修改时间")])]),v._v(" "),e("blockquote",[e("p",[v._v("一般缓存的资源都是GET请求的，因为像是POST和Option请求大部分请求内容和返回结果都不一样")])])])}),[],!1,null,null,null);_.default=a.exports}}]);